# 框架通识

## 从 MVC 到 MVVM

### MVC

![MVC](/mvc.png)

众所周知，MVC是最经典的开发模式之一。它主要由以下三个内容组成：

- Model：数据保存
- View: 用户界面
- Controller： 业务逻辑

MVC 模式将除了简单的 Model、View 以外的所有部分都被放在了 Controller 里面。Controller 负责显示界面、响应用户的操作、网络请求以及与 Model 交互。这就导致了 Controller 层：

- 逻辑复杂，难以维护
- 和 View 紧耦合

而 MVVM 的出现，则有效解决了 MVC 模式存在这几点问题。

### MVVM

![MVVM](/mvvm.png)

MVVM 由以下三个内容组成

- View：界面
- Model：数据模型
- ViewModel：作为桥梁负责沟通 View 和 Model

在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。

## 双向绑定

### 脏数据检测

当触发了指定事件后会进入脏数据检测，这时会调用 `$digest` 或者 `$apply()` 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 `$watch` 函数，然后再次调用 `$digest` 循环直到发现没有变化。循环至少为二次 ，至多为十次。

脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的。

### 数据劫持

Vue 内部使用了 `Object.defineProperty()` 函数，通过这个函数可以监听到 `set` 和 `get` 的事件。并配合观察者模式的使用，来实现数据的双向绑定。

值得一提的是，虽然 `Object.defineProperty` 已经可以实现数据的双向绑定，但是它还有以下几个不足：

- 只能对属性进行数据劫持，所以需要深度遍历整个对象
- 对于数组不能监听到数据的变化

这也是为什么 Vue 对于对象以及数组的操作时，提供一系列的变异方法和 `$set` 的原因。

那有什么更好的方案可以解决以上的问题吗？

答案是有的。ES6 新增的 `Proxy` 可以有效解决 `Object.defineProperty` 存在的问题。`Proxy` 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截。因此提供了一种机制，可以对外界的访问进行过滤和改写。

在下一个版本的更新中，Vue 将使用 `Proxy` 来替换 `Object.defineProperty`。

## 路由原理

前端路由本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式：

- hash 模式
- history 模式

## Virtual Dom

众所周知，操作 DOM 是很耗费性能的一件事情。既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多。

简单记录一下 Virtual Dom 实现的过程：

1. 通过 JS 来模拟创建 DOM 对象
2. 判断两个对象的差异
3. 渲染差异